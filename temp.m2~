pullbackCones = (nn,L) -> (
 X := smoothFanoToricVariety(nn,L#0);
  --the 'maximal' variety
 fulltDiv := tDivisorMap(nn,L);
 excDivs := select(numgens fulltDiv.source, i -> (
	 fulltDiv_i == vector(toList(numgens fulltDiv.target :0))));
 beta := {};
 while #L > 1 do (
   tDiv := tDivisorMap(nn,L);
   perm := select(
      (0,0)..(numgens tDiv.target -1, numgens tDiv.source -1), i -> 
      tDiv_i == 1);
--permutation of the divisors
   Perm := hashTable(toList perm); 
   Y := smoothFanoToricVariety(nn, last L);
   A1:= forbiddenSets Y;
--the forbidden sets for Y using the enumeration for Y
   forbiddens0 := apply(
       flatten values A1, i -> sort apply(i, j -> Perm#j));
--the forbidden sets for Y using the enumeration for X
   forbiddens := apply(forbiddens0, i -> sort toList(
	   set i - excDivs));
--removing the exceptional divisors from the forbidden sets
   beta = unique(beta|forbiddens);
   L = delete(last L, L);
	    );
 beta := toList(set beta - {{}});
 gamma0 := flatten values forbiddenSets X;
 gamma := select(gamma0, i -> not member(
	 sort toList(set i - excDivs),beta)); 
 
 d := #rays X;
 A := fromWDivToCl X;      
--to calculate the nonvanishing cones in the Picard lattice  
 cones := new MutableHashTable;
  	cones#0 = {map(ZZ^1,ZZ^(d-nn),0), (fourierMotzkin A)#0};
     	scan(1..nn, i -> cones#i = apply(gamma#i, s -> (
	  translation := - sum(s, j -> A_{j});
	  M := matrix table(d, d, (p,q) -> if p == q then 
	      (if member(p,s) then -1 else 1) else 0);
	  outerNorm := (fourierMotzkin (A*M))#0;
    {translation, outerNorm})));
  X.cache.cones = new HashTable from pairs cones;
  X.cache.cones)